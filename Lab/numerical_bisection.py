# -*- coding: utf-8 -*-
"""Numerical-bisection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nKuCzBQs3ahWdcktfkxujPN3DhVqCl2p
"""

def Bisection(a , b ,f , esp):
  i , checkEror , aOld  , bOld , mOld , epsErr = 0 ,1 , 0 ,0 ,0 , esp
  while checkEror > epsErr:
    mNew = (a+b)/2
    checkEror = abs(mNew - mOld)
    if f(mNew)*f(a) < 0:
      aOld = a
      bOld = b
      b = mNew
      StrCondition = "f(m)*f(a) < 0"
    elif f(mNew)*f(a) > 0:
      bOld = b
      aOld = a
      a = mNew
      StrCondition = "f(m)*f(a) > 0"
    i += 1
    print("i = ", i)
    print("a =" , aOld , "f(a) = ", f(aOld) , '"b = ', bOld , "f(b)", f(bOld))
    print("m = ", mNew , "f(m)" , f(mNew))
    print(StrCondition, " new interval is (", a,",", b, ") old interval is (", aOld ,",", bOld, ")")
    print("Eror = ", checkEror)
    print("-"*50)

    mOld = mNew

    if(i == 10000):
      print("Cannot find the root / Eror")
      checkEror = 0
      break
  return mNew

if __name__ == "__main__":
  esp = 10**(-6)
  f = lambda x : x**3 + 3*x**2 - 1
  root = Bisection(0,1,f,esp)
  print("root of eq : " , root)